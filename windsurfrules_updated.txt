# Rules - Global Development Principles & Practices:

## Accessibility-First Development:
-   Break down complex tasks into clear, manageable steps
-   Use consistent visual patterns and clear labeling
-   Implement step-by-step wizards for complex workflows
-   Provide visual progress indicators
-   Include clear error recovery paths
-   Support keyboard navigation throughout

## Documentation & Communication:
-   Document ALL steps in a clear, numbered format
-   Use visual aids (screenshots, diagrams) liberally
-   Maintain a running changelog with visual diffs
-   Create quick-reference guides for common tasks
-   Include video/gif demonstrations for complex features
-   Keep a centralized knowledge base for quick reference

## Code Organization & Memory Support:
-   Use descriptive, self-documenting names
-   Implement clear visual state indicators
-   Create checkpoints for long processes
-   Add status indicators for async operations
-   Use consistent color coding for different states
-   Implement auto-save where possible

# Development Environment:
-   {(IF Python is used, THEN)} ALWAYS use virtual environments (e.g., `venv`, `conda`) and ensure they are activated. Specify Python version explicitly (e.g., 3.11)
-   Specify Node.js version explicitly (e.g., 20.x)
-   Consistent use of a package manager (e.g., `npm`, `yarn`, `pip`)
-   IDE configuration for consistent formatting (e.g., Prettier, ESLint)
-   Use automated linting with clear error messages
-   Implement git hooks for consistency checks

# Code Organization & Refactoring:
-   Adhere to the 100-200 lines of code per file rule
-   Modularize code into reusable components and functions
-   Follow a consistent directory structure
-   Use clear and descriptive names for files, functions, variables, and components
-   Group related functionality visually
-   Include clear section comments

# Development Workflow:
-   ALWAYS separate Dev, Test, Prod environments and databases
-   ALWAYS preserve working code unless changes are explicitly requested
-   ALWAYS map out ALL affected files before making ANY changes
-   ALWAYS test each change in isolation
-   ALWAYS document each change in the change log (or Git commit messages)
-   ALWAYS prioritize low/zero-cost, open-source solutions
-   ALWAYS use version control (Git) for code changes
-   ALWAYS apply few-shot learning from successful architectures
-   ALWAYS produce technically excellent, yet practical solutions
-   ALWAYS use chain-of-hindsight reflection for long-term implications
-   ALWAYS avoid placeholders and mock data unless clearly labeled
-   ALWAYS remove redundant or unused code quickly
-   ALWAYS include visual progress indicators for long operations

# Error Handling:
-   Implement robust error handling to prevent app crashes
-   Log errors effectively for debugging
-   Provide user-friendly error messages
-   Include visual error indicators
-   Offer clear recovery steps
-   Maintain error state history

# Performance Optimization:
-   Optimize code for performance, especially in mobile (React Native)
-   Lazy-load resources where possible
-   Minimize network requests
-   Show loading states clearly
-   Implement progressive enhancement
-   Cache frequently used data

# Security Best Practices:
-   Follow secure coding practices to prevent vulnerabilities
-   Validate user input to prevent injection attacks
-   Securely store sensitive data
-   Use `fireward/fireward` to manage Firestore security rules
-   Implement clear security feedback
-   Show security status indicators

# VI. Testing Practices:
-   Write tests continuously with features/fixes.
-   Test expected functionality, edge cases, and failure points.
-   Test features/changes in isolation first.
-   Explain failures; enable rapid debugging.
-   Run full test suite in 'Test' environment after feature tests pass.
-   Address failures promptly: Fix code regression/bug OR update test for intended changes.
-   Commit ONLY after all tests pass.
-   Maintain tests alongside code (update/remove as needed).
-   Automate test execution where feasible (hooks, CI/CD).
-   Prioritize testing critical paths (auth, data, core logic, payments).
-   Improve code quality; don't just 'fix' tests to pass.
-   Apply 100-200 line limit to test files.
-   Use separate Dev/Test/Prod environments/DBs consistently.
-   Avoid unlabeled mock data/placeholders in tests.
-   Remove redundant/unused test code promptly.

# II. Technology-Specific Conventions:

## React Native:
-   Use functional components with hooks
-   Follow React best practices for state management
-   Use consistent styling (e.g., styled-components, StyleSheet)
-   Optimize for mobile performance
-   Properly handle asynchronous operations
-   Document component props and usage
-   Include visual feedback for all interactions

## Firebase:
-   Structure Firestore data according to the defined schema
-   Use appropriate Firestore queries and indexing
-   Secure Firestore rules using `fireward/fireward`
-   Use Firebase Cloud Functions for backend logic
-   Handle Firebase errors gracefully
-   Optimize Firebase Storage usage
-   Implement offline support

## JavaScript/TypeScript:
-   Use ES6+ features
-   Implement TypeScript for enhanced type safety
-   Follow consistent code formatting (Prettier)
-   Use linting (ESLint) to catch errors
-   Document code with JSDoc
-   Include clear type definitions

## CSS:
-   Use consistent naming convention (BEM)
-   Organize CSS files logically
-   Use CSS variables for theming
-   Optimize CSS performance
-   Implement clear visual hierarchies
-   Support high-contrast modes

# III. Project-Specific Conventions:

## Naming & Structure:
-   F.O.U.R. Naming: Use clear module prefixes (e.g., `ForgeWorkoutComponent`)
-   Color Scheme: Maintain navy blue, deep red, gold accents consistently
-   UI Consistency: Use consistent UI patterns
-   Chatbot Styling: Deep red AI bubbles, navy user bubbles

## Visual Feedback:
-   Always show loading states
-   Implement clear success/error indicators
-   Use consistent animation patterns
-   Provide visual confirmation of actions
-   Include progress indicators
-   Show clear state transitions

# IV. Code Review Practices:
-   Review code regularly
-   Focus on clarity and maintainability
-   Document review findings
-   Include visual before/after comparisons
-   Maintain a review checklist
-   Track recurring patterns

# V. Documentation Practices:
-   Document code thoroughly
-   Keep documentation current
-   Document schemas and APIs
-   Include setup instructions
-   Document architecture decisions
-   Create user guides
-   Add visual examples
-   Maintain quick-reference guides
